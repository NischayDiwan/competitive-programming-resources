# Understanding the template
* `bits/stdc++.h` is a header which contains all the commonly used headers we need, like `iostream`, `algorithm` etc. This is for our convenience so we can write code without worrying if we have included the appropriate header for the function/template we are using. It is also provided in all online judges when you select the gcc compiler option. Note that it will not be present on `clang` or `vsc++` compiler by default.
* When headers are included with `"..."`, it searches first in the current folder, and then it searches in the globally configured include paths. When `<...>` is used, it searches in the globally configured include path only. You can verify this by running `g++ template.cpp -v` in the terminal and seeing the `#include <...> search starts here:` lines, and also `g++ template.cpp -H` to see which headers are actually being used. 
* Here we are using a little trick, we have created a file `bits/stdc++.h` in our current CP folder, and appending the main `bits/stdc++.h` file to it, so this way we can add custom lines which we want to execute only when running on our local setup, but not when it is submitted online.
* The other two headers are used to get fast implementation of Tree Data Structures.
* When we write `cout<<"Hello World"<<endl;`, the endl first adds a new line character and also makes sure that the output is immediately given to the stdout, but when we write `cout<<'Hello World\n";`, it sometimes reduces no of times it has to call the output function by storing the string with \n in a "buffer", and then outputting all the strings at once to the stdout when the program has finished. This is why, using \n can be more efficient when the checker just needs to send all the input cases at once see the final output file after the program has finished. But, in interactive problems (Usually the last few toughest in a contest), the next line of input depends on the output you gave, hence we need to use `endl`. Comment out this line if the problem is interactive. Read codeforces [Interactive Problems: Guide for Participants](https://codeforces.com/blog/entry/45307)
* An `int` data type in C++ can store numbers roughly from `-2*10^9` to `2*10^9`, this may seem large, but in some problems, the numbers we are handling exceed this, so we use `long long` data type, which can store roughly from `-9*10^18` to `9*10^18`. `#define` here works like Find-and-Replace, it will find `int` in your code and replace it with `long long`, so it is a quick fix. You can also try `typedef long long ll;` or `using ll = long long;`
* Namespaces are used to organize code into logical groups and to prevent name collisions that can occur especially when your code base includes multiple libraries. `std` namespace contains most of the functions we will be using, if we don't use this line, we will have to write `std::cout<<` to specify the namespace.
* `1000000007` is a prime number and many problems ask you to take modulo by this number, so it is handy to uncomment it when needed.
* `solve()` function is for convenience and making the code look cleaner, so that the main logic of your code for that problem resides in this function. **TL;DR: This is where you will be writing most of your solution.**
* `signed` data type is same as `int`, but it does not get affected if you use `#define` statements for `int`. The C++ compiler wants the `main()` function to be `int` only and not other data type like `long long`, otherwise it may give errors.
* The `ios` and `tie` lines are believed to speed up i/o and make it faster.
* The lines under this block will execute only if `LOCAL` is defined using `#define`, this is done so that these lines execute only on your computer and not on the online judge, note that some have `ONLINE_JUDGE` defined, but that is not reliable for all servers. We can define `LOCAL` above our code, or in the custom `bits/stdc++.h` file we made.
* `freopen` lines will open the `input.txt` and `output.txt` from the current folder and assign them to `stdin` and `stdout`, so your program will read input from `input.txt`, and write the output to `output.txt`, this makes it convenient to take large test cases and also running against the same case many times without mistake by hand.
* We also have a timer, it will give a very accurate measurement of the execution time of your code, excluding the compilation time.
* Most problems require you to run your code `t` times. If the problem has only a single test case and so does not give `t`, you can comment out that line easily.


